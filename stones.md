<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$']]
    }
  };
</script>

<span style="color: #E5E4E4; font-family: Helvetica;">

### [Алгоритмы](README.md) / Динамическое программирование: Камни

# **Задача: Камни**
 
## **Условие:**
 
На столе изначально лежат $N$ камней. За ход игрок может взять

* $1$ или $2$ камня, если текущее число камней делится на $3$;
* $1$ или $3$, если текущее число камней при делении на $3$ дает остаток один;
* $1$, $2$ или $3$, если текущее число камней при делении на $3$ дает остаток два.

Каждый ход можно сделать при наличии достаточного количества камней. Проигрывает тот, кто хода сделать не может.

### **Входные данные**

Вводится целое число $0 < N \leq 100$.

### **Выходные данные**

Выведите $1$ или $2$ – номер игрока, который выиграет при правильной игре.

## **Разбор решения:**
 
Это один из примеров игровых задач на динамику. Чтобы понять принцип решения, давайте решим сначала более простую задачу, разновидностью которой являются «Камни»:
 
На столе лежит $N$ палочек. Каждый из двух игроков ходит по очереди. В свой ход игрок берет одну или две палочки. Проигрывает тот, кто взял последнюю палочку. По заданному числу палочек $N$ выведите номер игрока, у которого есть выигрышная стратегия.
 
Рассмотрим саму концепцию этой игры. Задача игрока $1$ – поставить игрока $2$ в такую ситуацию, в которой сам игрок $1$ проиграет. Для большего понимания рассмотрим ситуацию:
 
На столе лежат четыре палочки. Игрок $1$ точно знает, что если бы на столе лежало три или две палочки, он бы выиграл сам, но сейчас он проиграет. Он может взять только одну или две палочки, и тогда на столе останется три или две соответственно. То после того, как игрок $1$ сделал свой ход, ход делает игрок $2$, и уже он игрок $1$. В зависимости от ситуации новый игрок $1$ берет одну или две палочки и оставляет игроку $2$ последнюю палочку, так как он на выигрышной позиции.
 
Составим выражение, значение которого – правда, если игрок $1$ выигрывает, и ложь иначе:
 
$$win(N) = \sim win(N - 1) \vee \sim win(N - 2)$$
 
То есть игрок $1$ выигрывает только в том случае, если он проигрывает при количестве палочек, меньшем на $1$ или $2$, и проигрывает, если при количестве палочек, меньшем на $1$ или $2$, выигрывает. 
 
Поняв принцип решения, вернемся к задаче про камни. Тут формулой в одну строку не обойтись, задача усложнилась и появились условия:
 
$$N \mod 3 = 0: win(N) = \sim win(N - 1) \vee \sim win(N - 2)$$

$$N \mod 3 = 1: win(N) = \sim win(N - 1) \vee \sim win(N - 3)$$

$$N \mod 3 = 2: win(N) = \sim win(N - 1) \vee \sim win(N - 2) \vee \sim win(N - 3)$$
 
($mod$ – остаток от деления левого операнда на правый, $\sim$ – логическое *не*, $\vee$ – логическое *или*)

Выходит, что заолненная по этой формуле таблица выглядит так:

| $n$     |   1    |    2   |    3    |    4   |    5   |     6   | ... |
|---------|--------|--------|---------|--------|--------|---------|-----|
| решение | `True` | `True` | `False` | `True` | `True` | `False` | ... |
 
Из формулы следует, что нам нужно три проверки на делимость $N$ на $3$. В таблицу запишем значения для $N = 1$ и $N = 2$.
 
    memory = {1: True, 2: True}
 
Напоминаю, что функция вернет `True`, если при заданном количестве палочек выигрывает игрок $1$. Дальше просто программируем выведенную формулу:

```py
    memory = {1: True, 2: True}
    
    def win(n):
        if n in memory:
            return memory[n]
        else:
            if n % 3 == 0:
                    if not win(n - 1) or not win(n - 2):
                        memory[n] = True
                        return memory[n]
            if n % 3 == 1:
                    if not win(n - 1) or not win(n - 3):
                        memory[n] = True
                        return memory[n]
            if n % 3 == 2:
                    if not win(n - 1) or not win(n - 2) or not win(n - 3):
                        memory[n] = True
                        return memory[n]
        return False
```

Если окажется, что ни одно из условий не будет удовлетворено (у игрока $1$ нет никакой выигрышной стратегии), то функция вернет `False` (последняя строка).
