---
layout: default
---

<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$']]
    }
  };
</script>

### [Алгоритмы](index.md)/ Бинарный поиск

# **Бинарный поиск**

Дима загадал Паше некое число от $1$ до $100$, и задача Паши – отгадать это число как можно быстрее. Паша говорит Диме число, а Дима говорит, больше ли, меньше или равно названное число загаданному. Паша может пробовать все числа от $1$ до $100$ – $1$, $2$, $3$, $4$… но это долго. Немного подумав, Паша нашел оптимальный способ. 

Он спросил число $50$. Дима ответил: "Мало". Паша обрадовался, пусть он не угадал с первой попытки, но он уже забраковал половину всех чисел. Дальше он назвал число $75$ – "Много". Паша отсек еще четверть чисел. Теперь он назовет число $63$ – "Много". Следующая догадка – $57$ – "Угадал".

Паша воспользовался алгоритмом *бинарного поиска*. Скорее всего, вы догадались, как он работает:

<img src="assets/binsearch.png" alt="BFS" width="500"/>

Мы проводим поиск элемента в отсортированном (это условие обязательно) массиве, при этом мы знаем его правую и левую границу (если представить, что массив записан в строку от меньшего элемента к большему). 

Мы сравниваем наш элемент с центральным элементом между правой и левой границей. Если центральный элемент больше искомого, мы присваиваем правой границе индекс центрального элемента, если меньше – центральный элемент присваивается левой границе. Так мы делаем до тех пор, пока центральный между двумя границами элемент не будет равен искомому или пока границы не совпадут (они совпадут и с центральным, и с искомым элементом). Когда элемент найден, его индекс можно обработать (вернуть `True`, сам индекс и т. д.)

Стоит отметить, что на протяжении всего алгоритма поддерживается *инвариант* (неизменное условие) – нам всегда интересен только отрезок от левой до правой границы, и мы рассматриваем его пока индекс правой границы строго больше индекса левой на $1$.

В плане реализации алгоритм также несложный:

```py
    def binary_search(array, item):
        # задаем правые и левые границы 
        # изначально они совпадают с первым и последним индексом массива
        left = 0
        right = len(array) - 1
        
        while right - left > 1:
            # находим середину
            middle = (right + left) // 2
            if array[middle] == item:
                # обрабатываем значение (возвращаем место в массиве)
                return middle
            elif array[middle] > item:
                right = middle
            else:
                left = middle
```

Этот алгоритм работает за $O(\log N)$ операций, в то время как линейный поиск (перебор всех элементов массива) работает за $O(N)$ в худшем случае (если искомый элемент окажется последним). Чтобы не быть голословным, я попробую оба алгоритма на практике.

Есть два алгоритма, случайный массив и случайно выбранный элемент. Для начала сгенерируем массив на 100 элементов и засечем реальное время работы  для каждого алгоритма.

    binary search result -  61
    dumb search result -  61
    binary search execution time -  4.1962e-05
    dumb search execution time -  8.345e-06

Линейный поиск сработал за $0,000008345$ секунды, а бинарный – за $0,00004162$ секунды. Линейный однозначно справился быстрее, что неудивительно, понадобилась только $61$ операция. Да и разница небольшая – стотысячные доли секунды. Но стоит изменить длину массива до $10^7$ и картина сразу поменяется:

    binary search result -  7677643
    dumb search result -  7677643
    binary search execution time -  5.0068e-05
    dumb search execution time -  1.224620104

Время работы бинарного поиска увеличилось лишь на стотысячную долю секунды, в то время как перебор работает больше, чем за секунду (неудивительно – ему понадобилось выполнить $7×10^6$ операций), для большинства соревнований это медленно. 
